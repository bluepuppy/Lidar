// FFT to select freq. bins from signal on Teensy 3.2 pin A2 (ADC input)
// Set OUT_ALARM pin high if signal in some freq. bins over threshold
// Thanks to Teensy forum users: neutronned and Frank B.
// Tuned for signal from CDM324  (24GHz doppler sensor)
// by J.Beale 09-SEP-2017  T3.2 96 MHz Faster

#include <Audio.h>

AudioInputAnalog         adc1;       
AudioAnalyzeFFT1024      myFFT;
AudioConnection  patchCord1(adc1, myFFT);

#define SERPORT Serial1

#define A_GAIN (9.0)    // gain applied to analog input signal
#define LED1 (13)       // onboard signal LED
#define OUT_ALARM (3)   // alarm signal (motion detected)
#define BINS 15         // how many separate frequency bins to work with
#define BIN_CUTOFF (3)    // ignore bins below this value
//#define MOTION_THRESH (10)  // sum of alarm channels reaches this value = motion detect
#define MOTION_THRESH (6)  // sum of alarm channels exceeding this value = motion detect
#define PEAK_THRESH (4)  // largest bin must reach this value
#define DECRATIO (8)    // decimation ratio (data processed / printed out)
#define MINRUN (15)    // minimum # of cycles of motion before validated (displayed)
#define MINSTOP (2)    // minimum # of cycles of motion before validated (displayed)

#define UC unsigned char
#define UI unsigned int

#define MAX(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a > _b ? _a : _b; })  // this form used to avoid a double-evaluation problem

#define MIN(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a < _b ? _a : _b; })  // this form used to avoid a double-evaluation problem
     
#define FBINS 512    // full length of frequency data from 1024-point FFT
#define MINBOUND -100 // what log(0) becomes; should be at the noise floor, whatever that is

#define HISTBINS 50    // how many bins in background frequency histogram
#define FSCALEFAC 2  // histogram index scaling factor
#define FFSCALE (1000) // scaling factor for full FFT spectrum results
#define FFTHRESH (0.26) // full FFT element must exceed this threshold for motion signal
#define LOGSCALE (8.6859)  // scale factor converting ln(x) to 20*log10(x)  (dB units)

//float level[BINS];  // frequency bins, current smoothed value
//float avg[BINS];  // freq bins, long-term average
UC alarm[BINS];  // by what factor each bin exceeds threshold (0 = no alarm)
// UC hist[BINS];   // history buffer for early (pre-printout) motion alarm values
char buf[20];    // temporary string buffer for print output
// float dbuff[20][512];  // FFT result history buffer. (512 x 4 bytes/float) = 2k bytes of RAM
int didx=0;   // index into history buffer
UI ms; // current value of milliseconds
UI oldms = 0;  // previous loop value of msec
UI dt;     // delta-time (loop time) in msec


int sumAlarm;  // sum of all alarm[i] bins, 0 if no alarm
int iMax;      // index of bin with maximum 'Alarm' value

boolean motion = false;  // true if motion detected by alarm sum > MOTION_THRESH
boolean motionOld;  // motion value at previous timestep
boolean event = false;  // if currently in an event
boolean lastEvent = false; // if last cycle was an event
boolean firstPrint; // if this is the first line of motion data printed out
unsigned int runLength = 0;   // how many readings in a row "motion" has been detected
unsigned int stopLength = 0;  // how many readings in a row there's been no motion
unsigned int lastRun = 0;     // runlength duration of previous event 

static float fa = 0.1;  // smoothing fraction for low-pass filter
static float fb = 0.0005;  // smoothing fraction for long-term avg filter
static float fc = 0.3;     // smoothing fraction for center frequency
static float fmom = 0.4;  // moment smoothing
static float fmom2 = 0.35;  // moment smoothing
static float fmag = 0.4;  // magnitude smoothing
// static float aThresh = 0.17;      // amount by which current value must exceed long-ter avg. for alarm
// static float aThresh = 0.3;      // amount by which current value must exceed long-ter avg. for alarm (HB100)
static float aThresh = 0.20;      // amount by which current value must exceed long-ter avg. for alarm (CDM324)


unsigned int loops = 0;   // how many times through processing loop
unsigned int pcnt = 0;  // how many times through printout loop


float favg[FBINS];   // accumulated long-term average spectrum
float fsig[FBINS];   // motion signal spectrum = raw spectrum - long-term-average spectrum
float fMax;          // peak spectral value
int fiMax;           // index of peak value

float fCenter;  // center of mass of distribution
float fCenterSM1=0;  // center of mass of distribution
float fCenterSM2=0;  // center of mass of distribution
float moment = 0;  // moment of inertial about the center of mass, of signal spectrum
float momentSM = 0;  // smoothed version of moment of inertial
float momentSM2 = 0;  // smoothed version of moment of inertial
float oldmom3 = 0;    // value of momentSM2 during previous loop
float momentSM3 = 0;  // smooth #3
float momentSM4 = 0;  // smooth #4
UC    momvel;         // sign of moment slope (0 or 1 = + or -_
float mombase;        // base offset to subtract from moment
float oldmv;          // previous velocity
float fTotal;      // sum of all FFT elements 
float fSigTotal;   // sum of all detected-motion signals (above background average)
float fSigSM;      // smoothed fSigTotal

UC fHist[HISTBINS][FBINS];  // histogram of freq data to establish background thresholds
// unsigned char fHist[32][512];  // histogram of freq data to establish background thresholds


void setDACFreq(int freq) {  // change sampling rate of internal ADC and DAC
const unsigned config = PDB_SC_TRGSEL(15) | PDB_SC_PDBEN | PDB_SC_CONT | PDB_SC_PDBIE | PDB_SC_DMAEN;
    PDB0_SC = 0; //<--add this line
    PDB0_IDLY = 1;
    PDB0_MOD = round((float)F_BUS / freq ) - 1;    
    PDB0_SC = config | PDB_SC_LDOK;
    PDB0_SC = config | PDB_SC_SWTRIG;
    PDB0_CH0C1 = 0x0101;    
}

#define FSTEP(a,b,f) ( (1.0-f)*a + (f*b) )  // interpolate between (a,b) by fraction f
// =========================================================================

void updateAvgFull(float frac) {

// parameter 'frac' is long-term smoothing fraction (frac very small => very long-term avg.)

// Key: needs a well-chosen "threshold" factor above long-term average to count as a motion signal
// Single factor, parametric curve, or per-element lookup table?  How to determine?
//
// This function calculates:
//   fMax      (peak value of detected signal spectrum)
//   fiMax     (peak frequency of detected signal spectrum)
//   fTotal    (total of in raw spectrum)
//   fSigTotal (total of detected motion signal, 0 if all is average or below)
//   fCenter   (center frequency of detected signal spectrum, as an overall center-of-mass)
//   moment    (how spread-out in frequency the spectral data is)
//   momentSM  (smoothed / low-pass filtered version of moment)
  
  float fv;  // temporary float value of current spectral element
  float fsignal;  // signal = spectral element after background subtraction

  fTotal = 0;     // total signal in log space
  fSigTotal = 0;  // total detected (motion) signal
  fCenter = 0;
  fiMax = 0;
  fMax = 0.0;
  for (int i=0; i<FBINS; i++) {
      fv = FFSCALE * myFFT.read(i);    
      
      fTotal += fv;              // sum of raw spectral signal values
      if (!motion) {  // if there is no motion detected currently, update long-term average
        favg[i] = FSTEP(favg[i], fv, frac);  
      }
      fsignal = MAX( (fv - (favg[i] + FFTHRESH)) , 0);  // fsignal is always 0 or +.  0 if current value at or below average
      fSigTotal += fsignal;            // total detected signal (0 if all at or below average)
      
      fCenter += fsignal * ((float)i + 0.5);  // sum over all spectrum to find center-of-mass

      /*
      int j = fsignal * FSCALEFAC;  // very magical constant scale factor
      if (j > (HISTBINS-1)) j=HISTBINS-1; // make sure not to exceed a valid array index value
      // ---------------------------------------      
      if (!motion && (fsignal>0)) {  // update frequency histogram of "motion signal"
        if (fHist[j][i] < 255) fHist[j][i]++;  // histogram of freq data to establish background thresholds
      }
      // ---------------------------------------
      */
      
       
      if (fsig[i] > fMax) {   // have we found a new maximum?
        fMax = fsig[i];
        fiMax = i;
      }
      fsig[i] = fsignal;  // save this "detected signal" element of the spectrum
  } // end for (i..)
  fSigSM = FSTEP(fSigSM, fSigTotal, fmag); // smoothed version of signal magnitude
  if (fSigTotal > 0)
    fCenter /= (fSigTotal);  // this is the (non-integer) index value of "center of mass" of the spectrum
  else
    fCenter = 0;

  fCenterSM1 = FSTEP(fCenterSM1, fCenter, fc);  // update smoothed value
  fCenterSM2 = FSTEP(fCenterSM2, fCenterSM1, fc);  // update smoothed value
    
  moment = 0;  // moment of inertial about the center of mass, of signal spectrum
  for (int i=0; i<FBINS; i++) {
      float r=i;  // "radius" from center of mass of the spectrum
      moment += sqrt(fsig[i] * (r-fCenter)*(r-fCenter) );  // sqrt(moment) = Sum(m * r^2)    
  } // for(i..)  
  moment = MIN(moment/20.0, 100);  // arbitrary scaling and clamp value
  momentSM = FSTEP(momentSM, moment, fmom);  // update smoothed value
  momentSM2 = FSTEP(momentSM2, momentSM, fmom);  // update smoothed value #2
  momentSM3 = FSTEP(momentSM3, momentSM2, fmom);  // update smoothed value #3
  // momentSM4 = FSTEP(momentSM4, momentSM3, fmom2);  // update smoothed value #3
  if (momentSM3 > oldmom3) momvel = 1;  // calculate sign of moment velocity (increasing or decreasing?)
    else momvel = 0;
  if ( momvel==1 && oldmv==0 ) {  // just changed from down to up
    // mombase = oldmom3;
    mombase = momentSM3;
  }
  momentSM4 = momentSM3 - mombase;
  oldmv = momvel;
  oldmom3 = momentSM3;
} // end updateAvgFull()
// =========================================================================

void initHist() {
  for (int i=0; i<HISTBINS; i++)
    for (int j=0; j<FBINS; j++)
      fHist[HISTBINS][FBINS]=0;
} // end initHist()

void printHist() {  // print out histogram as PGM ASCII image
  int i,j;

  /*
  SERPORT.println("P2");  
  SERPORT.println("# SpectrumHistogram.pgm");  
  SERPORT.print(FBINS);  SERPORT.print(" ");  
  SERPORT.println(HISTBINS);  
  SERPORT.println("255");  
  for (i=0; i<HISTBINS; i++) {
    for (j=0; j<FBINS; j++) {
      SERPORT.print( fHist[i][j] );
      SERPORT.print(" "); // for PGM file this must be whitespace, not a comma
    }
    SERPORT.println();
  }
  SERPORT.println("# END SpectrumHistogram.pgm");  
*/

  SERPORT.println();
  // SERPORT.println("# Start fsig[]");
  for (j=0; j<FBINS; j++) {
    if (fsig[j] > 0) {
      SERPORT.print( j );
      SERPORT.print(",");
      SERPORT.print( fsig[j] );
      SERPORT.print(", ");
    }
  }

  SERPORT.println();
  //SERPORT.println("# ========================= ");

} // printHist()


// ==========================================
void setup() {
int i;

  AudioMemory(12);
  AudioNoInterrupts();
  setDACFreq(11025);
  // setDACFreq(25245); // 11.025 kHz * (24.1/10.525) = 25.245 kHz
  myFFT.windowFunction(AudioWindowHanning1024);
  // analogReference(EXTERNAL);  // set ADC voltage reference to 3.3V external
  AudioInterrupts();
  
  SERPORT.begin(19200);
  initHist();
  
  digitalWrite(LED1, false);
  pinMode(LED1, OUTPUT);
  digitalWrite(OUT_ALARM, false);
  pinMode(OUT_ALARM, OUTPUT);
  digitalWrite(LED1, true);
  digitalWrite(OUT_ALARM, true);
  delay(1000);

  // SERPORT.print("# log(10.0) = ");
  // SERPORT.println(log(10.0),5);
  SERPORT.println("count,freq,spread,det,strength");
  SERPORT.println("# CMD324 Doppler FFT on Teensy 3.2 ver 1.5 09-SEP-2017");
  /*
  for (i=0; i<8; i++) {
    delay(1000);
    SERPORT.print(".");
  }
  SERPORT.println();
  SERPORT.print("# ");
  */
  
  digitalWrite(LED1, false);
  digitalWrite(OUT_ALARM, false);
  runLength = 0;
  stopLength = 0;
  momentSM = 0;  // smoothed value of moment of detected spectrum

  for (i = 0; i<4; i++) do {} while (!myFFT.available());  // wait for FFT values to be ready  
  // updateLevel(1.0);  // initialize frequency values with instantaneous ones
  // updateAverage(1.0);  // initialize long-term average
  updateAvgFull(1.0);

  SERPORT.print("# ");
  for (i=0; i<100; i++) {  // do a few rounds of averaging
    while (!myFFT.available());
    SERPORT.print(".");
    // updateLevel(fa);  // start averaging frequency values 
    // updateAverage(fa/2.0);  // start long-term averaging
    updateAvgFull(fa/2.0);  // start long-term averaging
  }
  SERPORT.println("");
  SERPORT.println("# Starting now");

  firstPrint = false;
  // printData();           // starting values
  firstPrint = false;
  motionOld = false;

} // end setup()

// ===================================================================================
void loop() {
  int i;
  boolean tail = false;
  boolean mt;  // motion OR (tailend condition)

  
  if (myFFT.available()) {
    ms = millis();
    dt = ms - oldms;  // how long one loop takes
    oldms = ms;

    // updateLevel(fa);      // get current smoothed frequency values
    // updateAverage(fb);    // get long-term-average values
    updateAvgFull(fb);    // do stats on long-term-average of every element in full spectrum


    // "motion detected" when (sigMag > 0)
    // float sigMag = LOGSCALE * MAX(-0.5+log(fSigTotal), 0);  // magnitude in dB
    float sigMag = LOGSCALE * MAX(-0.5+log(fSigSM), 0);  // * LOGSCALE gives magnitude in dB
    
    motion = (sigMag > 0) & (fCenter > 0);
    if (motion) {
      stopLength = 0;
      runLength++;
    } else {
      // if ((runLength > 0) && (lastRun == 0))  lastRun = runLength;
      stopLength++;
    }

    // if ( (motion && (runLength > MINRUN)) || (!motion && (stopLength < MINSTOP)) ) {
    if ( motion && (runLength > MINRUN) ) {
      event = true;
    } else {
      event = false;
    }
    
    if (event == true) {
//      SERPORT.print(" ");
//      SERPORT.print(fiMax);  // index of max value over full FFT
//      SERPORT.print(",");
//      SERPORT.print(fMax);  //  max value over full FFT
//      SERPORT.print(",");

      SERPORT.print(runLength);  //  center of mass of spectrum
      SERPORT.print(",");
      SERPORT.print(fCenterSM2);  //  center of mass of spectrum
      SERPORT.print(",");
      SERPORT.print(momentSM3);  //  moment of inertia of signal
      SERPORT.print(",");
      SERPORT.print(momentSM4);  //  moment of inertia of signal
      SERPORT.print(",");
      SERPORT.print(sigMag,1);  //  log of total detected motion signal
      // printHist();
      SERPORT.println();
    } else {             // here we know (event == false)

      if (lastEvent) {  // just finished previous event ?
        // SERPORT.println(runLength);
        lastRun = 0;  // flag to indicate already printed
        SERPORT.println();  // blank line separates events
        runLength = 0;
      }
    }


    digitalWrite(OUT_ALARM, motion);
    // digitalWrite(LED1, motion);  // onboard LED current adds noise?    

    lastEvent = event;  // remember if we are in event, for next cycle
  
  } // if (myFFT.available...)
  
} // end main loop()

